package org.tb.bdom;

import java.io.Serializable;
import java.sql.Date;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;

import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;
import org.hibernate.annotations.Cascade;
import org.hibernate.annotations.CascadeType;
import org.hibernate.annotations.Fetch;
import org.hibernate.annotations.FetchMode;
import org.tb.GlobalConstants;

/**
 * Bean for table 'Employeecontract'.
 * 
 * @author oda
 */
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Employeecontract implements Serializable {
    
    private static final long serialVersionUID = 1L; // 1L;
    
    /**
     * Autogenerated technical object id.
     */
    @Id
    @GeneratedValue
    private long id;
    
    /** id of the supervisor */
    @ManyToOne
    @Fetch(FetchMode.SELECT)
    @JoinColumn(name = "SUPERVISOR_ID")
    @Cascade(value = { CascadeType.SAVE_UPDATE })
    private Employee supervisor;
    
    /** valid from date */
    private Date validFrom;
    
    /** valid until date */
    private Date validUntil;
    
    /** daily working time */
    private Double dailyWorkingTime;
    
    /** freelancer y/n */
    private Boolean freelancer;
    
    /** task description */
    private String taskDescription;
    
    /** fixed until date */
    private Date fixedUntil;
    
    /** report acceptance date */
    private java.sql.Date reportAcceptanceDate;
    
    /** report release date */
    private java.sql.Date reportReleaseDate;
    
    /** Creation Date */
    private java.util.Date created;
    
    /** Last Update */
    private java.util.Date lastupdate;
    
    /** Created By */
    private String createdby;
    
    /** Updated By */
    private String lastupdatedby;
    
    /** Update Counter */
    private Integer updatecounter;
    
    /** Hide Flag */
    private Boolean hide;
    
    /** static overtime from begin of employeecontract to reportAcceptanceDate*/
    private double overtimeStatic;
    
    /** boolean for new overtime computation: if true, overtimeStatic has not been set before*/
    private Boolean useOvertimeOld;
    
    /** Employee */
    @OneToOne
    // FIXME check if ManyToOne?
    @Fetch(FetchMode.SELECT)
    @JoinColumn(name = "EMPLOYEE_ID")
    @Cascade(value = { CascadeType.SAVE_UPDATE })
    private Employee employee;
    
    /** list of timereports, associated to this employeecontract */
    @OneToMany(mappedBy = "employeecontract")
    @Cascade(value = { CascadeType.SAVE_UPDATE })
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private List<Timereport> timereports;
    
    /** list of employeeorders, associated to this employeecontract */
    @OneToMany(mappedBy = "employeecontract")
    @Cascade(value = { CascadeType.SAVE_UPDATE })
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private List<Employeeorder> employeeorders;
    
    /** list of monthlyreports, associated to this employeecontract */
    @OneToMany(mappedBy = "employeecontract")
    @Cascade(value = { CascadeType.SAVE_UPDATE })
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private List<Monthlyreport> monthlyreports;
    
    /** list of vacations, associated to this employeecontract */
    @OneToMany(mappedBy = "employeecontract")
    @Cascade(value = { CascadeType.SAVE_UPDATE })
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private List<Vacation> vacations;
    
    public long getId() {
        return id;
    }
    
    public void setId(long id) {
        this.id = id;
    }
    
    public Double getDailyWorkingTime() {
        return dailyWorkingTime;
    }
    
    public void setDailyWorkingTime(Double dailyWorkingTime) {
        this.dailyWorkingTime = dailyWorkingTime;
    }
    
    public Boolean getFreelancer() {
        if (freelancer == null) {
            freelancer = false;
        }
        return freelancer;
    }
    
    public void setFreelancer(Boolean freelancer) {
        this.freelancer = freelancer;
    }
    
    public String getTaskDescription() {
        return taskDescription;
    }
    
    public void setTaskDescription(String taskDescription) {
        this.taskDescription = taskDescription;
    }
    
    public Date getFixedUntil() {
        return fixedUntil;
    }
    
    public void setFixedUntil(Date fixedUntil) {
        this.fixedUntil = fixedUntil;
    }
    
    public Date getValidFrom() {
        return validFrom;
    }
    
    public void setValidFrom(Date validFrom) {
        this.validFrom = validFrom;
    }
    
    public Date getValidUntil() {
        return validUntil;
    }
    
    public void setValidUntil(Date validUntil) {
        this.validUntil = validUntil;
    }
    
    public Employee getEmployee() {
        return employee;
    }
    
    public void setEmployee(Employee employee) {
        this.employee = employee;
    }
    
    public List<Timereport> getTimereports() {
        return timereports;
    }
    
    public void setTimereports(List<Timereport> timereports) {
        this.timereports = timereports;
    }
    
    public List<Employeeorder> getEmployeeorders() {
        return employeeorders;
    }
    
    public void setEmployeeorders(List<Employeeorder> employeeorders) {
        this.employeeorders = employeeorders;
    }
    
    public List<Monthlyreport> getMonthlyreports() {
        return monthlyreports;
    }
    
    public void setMonthlyreports(List<Monthlyreport> monthlyreports) {
        this.monthlyreports = monthlyreports;
    }
    
    public List<Vacation> getVacations() {
        //		for (Vacation vacation : vacations) {
        //			vacation.getId();
        //		}
        return vacations;
    }
    
    public void setVacations(List<Vacation> vacations) {
        this.vacations = vacations;
    }
    
    public java.sql.Date getReportAcceptanceDate() {
        return reportAcceptanceDate;
    }
    
    public String getReportAcceptanceDateString() {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(GlobalConstants.DEFAULT_DATE_FORMAT);
        if (reportAcceptanceDate != null) {
            return simpleDateFormat.format(reportAcceptanceDate);
        } else {
            return simpleDateFormat.format(validFrom);
        }
    }
    
    public void setReportAcceptanceDate(java.sql.Date reportAcceptanceDate) {
        this.reportAcceptanceDate = reportAcceptanceDate;
    }
    
    public java.sql.Date getReportReleaseDate() {
        return reportReleaseDate;
    }
    
    public String getReportReleaseDateString() {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(GlobalConstants.DEFAULT_DATE_FORMAT);
        if (reportReleaseDate != null) {
            return simpleDateFormat.format(reportReleaseDate);
        } else {
            return simpleDateFormat.format(validFrom);
        }
    }
    
    public void setReportReleaseDate(java.sql.Date reportReleaseDate) {
        this.reportReleaseDate = reportReleaseDate;
    }
    
    /**
     * @return the created
     */
    public java.util.Date getCreated() {
        return created;
    }
    
    /**
     * @param created the created to set
     */
    public void setCreated(java.util.Date created) {
        this.created = created;
    }
    
    /**
     * @return the createdby
     */
    public String getCreatedby() {
        return createdby;
    }
    
    /**
     * @param createdby the createdby to set
     */
    public void setCreatedby(String createdby) {
        this.createdby = createdby;
    }
    
    /**
     * @return the lastupdate
     */
    public java.util.Date getLastupdate() {
        return lastupdate;
    }
    
    /**
     * @param lastupdate the lastupdate to set
     */
    public void setLastupdate(java.util.Date lastupdate) {
        this.lastupdate = lastupdate;
    }
    
    /**
     * @return the lastupdatedby
     */
    public String getLastupdatedby() {
        return lastupdatedby;
    }
    
    /**
     * @param lastupdatedby the lastupdatedby to set
     */
    public void setLastupdatedby(String lastupdatedby) {
        this.lastupdatedby = lastupdatedby;
    }
    
    /**
     * @return the updatecounter
     */
    public Integer getUpdatecounter() {
        return updatecounter;
    }
    
    /**
     * @param updatecounter the updatecounter to set
     */
    public void setUpdatecounter(Integer updatecounter) {
        this.updatecounter = updatecounter;
    }
    
    /**
     * @return the hide
     */
    public Boolean getHide() {
        return hide;
    }
    
    /**
     * @param hide the hide to set
     */
    public void setHide(Boolean hide) {
        this.hide = hide;
    }
    
    public double getOvertimeStatic() {
        return overtimeStatic;
    }
    
    public void setOvertimeStatic(double overtimeStatic) {
        this.overtimeStatic = overtimeStatic;
    }
    
    public Boolean getUseOvertimeOld() {
        return useOvertimeOld;
    }
    
    public void setUseOvertimeOld(Boolean useOvertimeOld) {
        this.useOvertimeOld = useOvertimeOld;
    }
    
    public String getTimeString() {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(GlobalConstants.DEFAULT_DATE_FORMAT);
        if (validUntil == null) {
            return simpleDateFormat.format(validFrom) + " - ";
        }
        return simpleDateFormat.format(validFrom) + " - " + simpleDateFormat.format(validUntil);
    }
    
    public Boolean getOpenEnd() {
        if (validUntil == null) {
            return true;
        }
        return false;
    }
    
    public Integer getVacationEntitlement() {
        if (vacations != null && vacations.size() > 0) {
            // actually, vacation entitlement is a constant value
            // for an employee (not year-dependent), so just take the
            // first vacation entry to get the value
            return vacations.get(0).getEntitlement();
        }
        else {
            return GlobalConstants.VACATION_PER_YEAR;
        }
    }
    
    /**
     * Checks, if the employeecontract is released until the last day of the preceding month.
     * @return Returns true, if the contract is not released until the last day of the preceding month, false otherwise.
     */
    public boolean getReleaseWarning() {
        boolean releaseWarning = false;
        GregorianCalendar calendar = new GregorianCalendar();
        Date release = getReportReleaseDate();
        
        if (release == null) {
            // new contract without initial login
            return false;
        }
        
        java.util.Date now = new java.util.Date();
        int month = calendar.get(Calendar.MONTH);
        int year = calendar.get(Calendar.YEAR);
        
        if (month == 0) {
            year--;
            month = 11;
        } else {
            month--;
        }
        calendar.clear();
        calendar.set(Calendar.MONTH, month);
        calendar.set(Calendar.YEAR, year);
        int date = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);
        calendar.set(Calendar.DATE, date);
        now = calendar.getTime();
        
        if (release.before(now)) {
            releaseWarning = true;
        }
        return releaseWarning;
    }
    
    /**
     * Checks, if the employeecontract is accepted until the last day of the preceding month.
     * @return Returns true, if the contract is not accepted until the last day of the preceding month, false otherwise.
     */
    public boolean getAcceptanceWarning() {
        boolean acceptanceWarning = false;
        GregorianCalendar calendar = new GregorianCalendar();
        Date acceptance = getReportAcceptanceDate();
        
        if (acceptance == null) {
            // new contract without initial login
            return false;
        }
        
        java.util.Date now = new java.util.Date();
        int month = calendar.get(Calendar.MONTH);
        int year = calendar.get(Calendar.YEAR);
        
        if (month == 0) {
            year--;
            month = 11;
        } else {
            month--;
        }
        calendar.clear();
        calendar.set(Calendar.MONTH, month);
        calendar.set(Calendar.YEAR, year);
        int date = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);
        calendar.set(Calendar.DATE, date);
        now = calendar.getTime();
        
        if (acceptance.before(now)) {
            acceptanceWarning = true;
        }
        return acceptanceWarning;
    }
    
    /**
     * 
     * @return Returns true, if the {@link Employeecontract} is currently valid, false otherwise.
     */
    public boolean getCurrentlyValid() {
        java.util.Date now = new java.util.Date();
        if (!now.before(getValidFrom()) && (getValidUntil() == null || !now.after(getValidUntil()))) {
            return true;
        }
        return false;
    }
    
    /* (non-Javadoc)
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
        final int PRIME = 31;
        int result = 1;
        result = PRIME * result + (int)(id ^ id >>> 32);
        return result;
    }
    
    /* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Employeecontract other = (Employeecontract)obj;
        if (id != other.id) {
            return false;
        }
        return true;
    }
    
    /**
     * Checks, if the employeecontract is accepted until the last day of the preceding month.
     * @return Returns true, if the contract is not accepted until the last day of the preceding month, false otherwise.
     */
    public boolean getAcceptanceWarningByDate(java.util.Date now) {
        boolean acceptanceWarning = false;
        GregorianCalendar calendar = new GregorianCalendar();
        Date acceptance = getReportAcceptanceDate();
        
        if (acceptance == null) {
            // new contract without initial login
            acceptance = validFrom;
        }
        calendar.setTime(now);
        int month = calendar.get(Calendar.MONTH);
        int year = calendar.get(Calendar.YEAR);
        
        if (month == 0) {
            year--;
            month = 11;
        } else {
            month--;
        }
        calendar.clear();
        calendar.set(Calendar.MONTH, month);
        calendar.set(Calendar.YEAR, year);
        int date = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);
        calendar.set(Calendar.DATE, date);
        now = calendar.getTime();
        
        if (acceptance.before(now)) {
            acceptanceWarning = true;
        }
        return acceptanceWarning;
    }
    
    public Employee getSupervisor() {
        return supervisor;
    }
    
    public void setSupervisor(Employee supervisor) {
        this.supervisor = supervisor;
    }
}
